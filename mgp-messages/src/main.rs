//! Service to query and assemble posts into timelines.
#![crate_name = "mgp_messages"]
#![warn(
    bad_style,
    dead_code,
    improper_ctypes,
    non_shorthand_field_patterns,
    no_mangle_generic_items,
    overflowing_literals,
    path_statements,
    patterns_in_fns_without_body,
    private_in_public,
    unconditional_recursion,
    unused,
    unused_allocation,
    unused_comparisons,
    unused_parens,
    while_true,
    missing_debug_implementations,
    missing_docs,
    trivial_casts,
    trivial_numeric_casts,
    unused_extern_crates,
    unused_import_braces,
    unused_qualifications,
    unused_results,
    unused_variables
)]

use diesel::pg::PgConnection;
use diesel::prelude::*;
use dotenvy::dotenv;
use hyper::StatusCode;
use std::collections::HashMap;
use std::env;
use uuid::Uuid;
use warp::{Filter, Reply, Rejection};

use crate::query::PostQueryParams;

/// Queryable objects mapped to DB Table Rows.
mod models;
/// Deserializing query param strings (see the README)
mod query;
/// DB Schema Autogenerated by Diesel
#[allow(clippy::all)]
#[allow(warnings, unused, nonstandard_style)]
mod schema;

#[tokio::main]
async fn main() -> eyre::Result<()> {
    use self::schema::posts::dsl::*;

    let mut conn = establish_connection();

    let all_post_ids: Vec<Uuid> = posts.select(id).load(&mut conn).unwrap();
    println!("{all_post_ids:#?}");

    serve().await?;

    Ok(())
}

fn establish_connection() -> PgConnection {
    _ = dotenv().ok();

    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    PgConnection::establish(&database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}

async fn serve() -> eyre::Result<()> {
    let getposts = warp::path("posts")
        .and(warp::path::param::<String>())
        .and(warp::query::<HashMap<String, String>>())
        .and(warp::get())
        .map(get_post);

    let getuserposts = warp::path("search")
        .and(warp::path("all"))
        .and(warp::path::param::<String>())
        .and(warp::query::<HashMap<String, String>>())
        .and(warp::get())
        .map(|post_id: String, params| format!("search all {post_id} + {params:#?}"));

    let getuserfollows = warp::path("search")
        .and(warp::path("follows"))
        .and(warp::path::param::<String>())
        .and(warp::query::<HashMap<String, String>>())
        .and(warp::get())
        .map(|post_id: String, params| format!("search follows {post_id} + {params:#?}"));

    let getsearch = warp::path("search")
        .and(warp::path("all"))
        .and(warp::query::<HashMap<String, String>>())
        .and(warp::get())
        .map(|params| format!("search all + {params:#?}"));

    let invalidendpoint = warp::any().map(|| {
        Ok(warp::reply::with_status(
            "METHOD_NOT_ALLOWED",
            StatusCode::METHOD_NOT_ALLOWED,
        ))
    });

    let routes = getposts
        .or(getuserposts)
        .or(getuserfollows)
        .or(getsearch)
        .or(invalidendpoint);
    warp::serve(routes).run(([127, 0, 0, 1], 3031)).await;

    Ok(())
}

fn get_post(post_id: String, params: HashMap<String, String>) -> Result<impl Reply, hyper::http::Error> {
    let params = match PostQueryParams::from_query_params(params) {
        Err(e) => return Ok(warp::reply::with_status(format!("BAD_QUERY ({e})"), StatusCode::BAD_REQUEST)),
        Ok(p) => p,
    };

    Ok(warp::reply::with_status(format!("{post_id}\n{params:#?}"), StatusCode::OK))
}